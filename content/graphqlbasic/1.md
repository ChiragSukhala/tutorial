+++
date = "2017-04-26T22:36:18+10:00"
next = "/graphqlbasic/2"
prev = "/graphqlintro/9"
title = "Hello World"
weight = 1
type = "graphql"
+++

{{% notice "note" %}}
  For the following queries to run, you should have completed the introduction to setup your backend, define your schema, and insert the sample data. [introduction](../../intro/1/).
{{% /notice %}}

Letâ€™s have a look at a hello world query in DQL.

Every query has at least one named root function and the results will be labeled with the same.

Dgraph generates these functions based upon the schema a user provides. In the Introduction, we provided two types, 'person' and 'animal'. For each type Dgraph can generate 3 GraphQL queries, `get<Type>`, `query<Type>`, and `aggregate<Type>`. For our 2 types provided Dgraph generated the following queries:

- `getPerson`
- `queryPerson`
- `aggregatePerson`
- `getAnimal`
- `queryAnimal`
- `aggregateAnimal`

The `getPerson` and `getAnimal` queries require an input identifying the single node of that type to return. The `queryPerson` and `queryAnimal` queries by default return all the nodes of that type. These queries can be provided inputs to filter, order, and paginate through the nodes. The `aggregatePerson` and `aggregateAnimal` queries return aggregated calculations but do not return the nodes themselves. The most common use cases of `aggregate<Type>` queries is to count the number of nodes. Aggregae queries can accept a filter argument for aggregating a filtered selection of nodes.

Dgraph identifies each node with a unique internal id, its UID. This UID can be mapped to a field in the GraphQL schema by using the ID scalar. In the GraphQL schema, Dgraph also provides a mechanism for referencing nodes by external ids, its XID. An XID can be mapped to a field in the schema by using the `@id` directive. In our example schema, we mapped the UID to the `id` field and the XID to the `xid` field of each type. You do not need to use either of these to perform `query<Type>` queries, but in order to use the `get<Type>` queries you will need to use at least one of these id mechanisms. Since we use mapped both UIDs and XIDs we are able to use the `get<Type>` with either of these identifying fields.

Field selection is done by providing a list of the fields wanted from the query. In our example query, we are requesting the `id`, `xid`, `name`, and `age`. For any field that does not have a set value `null` will be returned.

Run the query example we provided to see the results returned.

You will see right away that the results are in JSON format and take the same shape of the query requested.

Something to try : Change the query to select someone else.
You can check the [sample data](../../intro/4) again.

{{% expandable %}}
Find an xid in the data and try
```
{
  getPerson(xid: "<XID here>") {
    id
    name
    age
  }
}
```
Or look at the `UID`s in the responses and try
```
{
  getPerson(id: "<UID here>") {
    xid
    name
    age
  }
}
Or try to get an animal instead with
```
{
  getAnimal(xid: "<XID here>") {
    id
    name
  }
}
```
You can edit the queries and try whatever you like.  When there are
answers like this, you can copy and paste them into the query panel, then edit and run them.
{{% /expandable %}}

The tutorial will handle connecting the client to the GraphQL API, so just focus on the query syntax for now.
